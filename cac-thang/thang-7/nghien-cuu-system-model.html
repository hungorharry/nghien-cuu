<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sơ đồ Phương Pháp Học Từ Vựng PTE</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f0f2f5 0%, #e0e5ec 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Để có không gian cho bộ điều khiển */
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 1200px;
        }
        
        .controls-container {
            background-color: #e6e9ef;
            padding: 20px;
            border-radius: 16px;
            box-shadow: 
                inset -6px -6px 12px rgba(255, 255, 255, 0.9),
                inset 6px 6px 12px rgba(0, 0, 0, 0.1);
            margin-bottom: 25px;
            width: min(95vw, 1000px);
        }
        .controls-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: #334155;
            text-align: center;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }
        .control-item {
            display: flex;
            align-items: center;
            background: #f0f2f5;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .control-item:hover {
            background-color: #dde1e7;
        }
        .control-item input[type="checkbox"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            accent-color: #10B981;
            cursor: pointer;
        }
        .control-item label {
            color: #475569;
            font-weight: 600;
            cursor: pointer;
            flex-grow: 1;
        }

        .diagram-container {
            position: relative;
            width: min(95vw, 1000px);
            height: min(95vw, 1000px);
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #e6e9ef;
            border-radius: 30px;
            box-shadow: 
                -12px -12px 24px rgba(255, 255, 255, 0.9),
                12px 12px 24px rgba(0, 0, 0, 0.1);
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .circle-node {
            position: absolute;
            background-color: #334155;
            color: #ffffff;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 0.8rem;
            padding: 10px;
            box-sizing: border-box;
            line-height: 1.3;
            box-shadow: 0 6px 12px rgba(51, 65, 85, 0.35);
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            cursor: pointer;
            word-break: break-word;
            border: 3px solid #475569;
            z-index: 10;
        }

        .circle-node:hover {
            transform: scale(1.1);
            background-color: #1e293b;
            box-shadow: 0 8px 18px rgba(30, 41, 59, 0.5);
        }

        .circle-node.highlight {
            background-color: #10B981;
            box-shadow: 0 8px 20px rgba(16, 185, 129, 0.4);
            border: 3px solid #059669;
        }

        .circle-node.highlight:hover {
            background-color: #059669;
            transform: scale(1.15);
            box-shadow: 0 10px 25px rgba(16, 185, 129, 0.55);
        }

        .circle-node .rank-label {
            font-size: 0.75em;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 3px;
            text-transform: uppercase;
        }
        .circle-node.highlight .rank-label { color: #ffffff; }
        
        @media (min-width: 768px) {
            .circle-node { font-size: 1rem; padding: 15px; }
            .circle-node .rank-label { font-size: 0.85em; }
        }
        
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(15, 23, 42, 0.7); backdrop-filter: blur(5px);
            display: flex; align-items: center; justify-content: center;
            z-index: 1000; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.show { opacity: 1; visibility: visible; }
        .modal-content {
            background-color: #ffffff; padding: 30px 40px; border-radius: 16px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
            max-width: 800px;
            width: 90%; position: relative;
            transform: scale(0.95) translateY(-20px);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            max-height: 85vh; overflow-y: auto;
        }
        .modal-content::-webkit-scrollbar { width: 8px; }
        .modal-content::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        .modal-content::-webkit-scrollbar-thumb { background: #a8a8a8; border-radius: 10px; }
        .modal-content::-webkit-scrollbar-thumb:hover { background: #888; }
        .modal-overlay.show .modal-content { transform: scale(1) translateY(0); }
        .modal-title { font-size: 2rem; font-weight: 700; color: #1e293b; margin-bottom: 10px; text-align: center; }
        .modal-body { font-size: 1rem; color: #334155; line-height: 1.7; text-align: left; }
        .modal-body h3 { font-size: 1.5rem; font-weight: 600; color: #10B981; margin-top: 25px; margin-bottom: 15px; border-bottom: 2px solid #e2e8f0; padding-bottom: 8px; }
        .modal-body h4 { font-size: 1.15rem; font-weight: 700; color: #0f172a; margin-top: 20px; margin-bottom: 8px; }
        .modal-body strong { color: #0f172a; font-weight: 700; }
        .modal-body ul { list-style-type: none; padding-left: 10px; margin-top: 10px; }
        .modal-body li { position: relative; padding-left: 25px; margin-bottom: 10px; }
        .modal-body li::before { content: '✓'; position: absolute; left: 0; top: 1px; color: #10B981; font-weight: bold; }
        .modal-footer { margin-top: 30px; text-align: center; }
        .modal-close-btn { background-color: #ef4444; color: #ffffff; padding: 12px 28px; border-radius: 8px; border: none; cursor: pointer; font-size: 1rem; font-weight: 600; transition: background-color 0.2s ease, transform 0.2s ease; }
        .modal-close-btn:hover { background-color: #dc2626; transform: translateY(-2px); }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="controls-container">
            <h3 class="controls-title">Các Phương Pháp Học Từ Vựng PTE Hiệu Quả</h3>
            <div id="controlsGrid" class="controls-grid"></div>
        </div>

        <div id="diagramContainer" class="diagram-container">
            <canvas id="diagramCanvas"></canvas>
        </div>
    </div>

    <div id="tooltipModal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="modalTitle" class="modal-title"></h2>
            <div id="modalBody" class="modal-body"></div>
            <div class="footer">
                <button id="closeModalBtn" class="modal-close-btn">Đóng</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('diagramContainer');
            const canvas = document.getElementById('diagramCanvas');
            const ctx = canvas.getContext('2d');
            const controlsGrid = document.getElementById('controlsGrid');
            const tooltipModal = document.getElementById('tooltipModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalBody = document.getElementById('modalBody');
            const closeModalBtn = document.getElementById('closeModalBtn');

            const nodeData = [
                { 
                    "text": "Học theo Chủ đề & Ngữ cảnh", 
                    "highlight": true, 
                    "rank": 1,
                    "connections": ["Đọc Chủ động", "Nghe & Xem Chủ động", "Flashcards & Lặp lại ngắt quãng"],
                    "tooltip": "Đây là phương pháp **nền tảng và quan trọng nhất**. Thay vì học các từ riêng lẻ, hãy học chúng trong một cụm câu, một đoạn văn hoặc một chủ đề cụ thể. Điều này giúp bạn hiểu sâu sắc cách dùng từ và ghi nhớ lâu hơn.\n### Tại sao lại quan trọng với PTE?\n- PTE là bài thi học thuật, từ vựng thường xoay quanh các chủ đề cố định như: **Môi trường, Giáo dục, Công nghệ, Y tế, Xã hội...**\n- Các dạng bài như **Fill in the Blanks** hay **Summarize Spoken Text** đều đòi hỏi khả năng hiểu từ vựng trong ngữ cảnh.\n### Cách thực hiện:\n- **Bước 1:** Xác định các chủ đề thường gặp trong PTE.\n- **Bước 2:** Tìm các bài đọc, bài nghe, video liên quan đến chủ đề đó.\n- **Bước 3:** Khi gặp từ mới, đừng chỉ ghi lại từ đó. Hãy ghi lại **cả câu chứa từ đó**."
                },
                { 
                    "text": "Đọc Chủ động", 
                    "rank": 2,
                    "connections": ["Học theo Chủ đề & Ngữ cảnh", "Tập trung vào Collocations", "Luyện tập Sản sinh"],
                    "tooltip": "Đọc không chỉ để hiểu nội dung mà còn là một công cụ săn tìm từ vựng. Đọc chủ động có nghĩa là bạn tương tác sâu với văn bản.\n### Biểu hiện của đọc chủ động:\n- **Gạch chân/Tô sáng:** Đánh dấu từ mới, collocations hay, và các cấu trúc ngữ pháp phức tạp.\n- **Ghi chú bên lề:** Tóm tắt ý chính của đoạn văn, đặt câu hỏi, hoặc viết lại định nghĩa của từ mới theo cách hiểu của bạn.\n- **Tra cứu thông minh:** Không chỉ tra nghĩa của từ, mà còn xem cả cách phát âm, word family (gia đình từ) và các ví dụ.\n### Nguồn để đọc:\n- **Báo học thuật:** New Scientist, The Economist, National Geographic.\n- **Trang tin tức uy tín:** BBC, The Guardian, Reuters.\n- **Các bài đọc mẫu PTE:** Từ các nguồn luyện thi chính thống."
                },
                { 
                    "text": "Nghe & Xem Chủ động", 
                    "rank": 3,
                    "connections": ["Học theo Chủ đề & Ngữ cảnh", "Tập trung vào Collocations", "Luyện tập Sản sinh"],
                    "tooltip": "Tương tự như Đọc chủ động, phương pháp này biến việc nghe/xem thụ động thành một buổi học tích cực. Kỹ năng này cực kỳ quan trọng cho các phần thi như **Summarize Spoken Text** và **Write from Dictation**.\n### Cách thực hiện:\n- **Nghe và chép chính tả (Transcription):** Chọn một đoạn audio/video ngắn (1-2 phút) và cố gắng chép lại chính xác từng từ. Đây là cách luyện tai và phát hiện từ mới hiệu quả nhất.\n- **Shadowing (Nói nhại):** Lặp lại ngay lập tức những gì người bản xứ nói. Kỹ thuật này giúp cải thiện phát âm, ngữ điệu và ghi nhớ các cụm từ một cách tự nhiên.\n### Nguồn để nghe/xem:\n- **TED Talks:** Nguồn video học thuật đa dạng chủ đề với phụ đề chính xác.\n- **Podcasts:** Tìm các podcast về khoa học, lịch sử, kinh tế (ví dụ: '60-Second Science').\n- **Bài giảng online:** Các bài giảng ngắn trên Coursera, edX hoặc YouTube."
                },
                { 
                    "text": "Flashcards & Lặp lại ngắt quãng", 
                    "rank": 4, 
                    "connections": ["Học theo Chủ đề & Ngữ cảnh", "Ôn tập & Tự kiểm tra", "Tận dụng Công cụ & Ứng dụng"],
                    "tooltip": "Đây là phương pháp **ghi nhớ** từ vựng một cách khoa học. Thay vì học nhồi nhét, bạn sẽ ôn lại từ vựng vào những thời điểm tối ưu trước khi bạn kịp quên nó.\n### Spaced Repetition System (SRS) là gì?\n- Đây là một thuật toán giúp lên lịch ôn tập. Những từ bạn hay quên sẽ xuất hiện thường xuyên hơn, còn những từ bạn đã thuộc sẽ xuất hiện ít lại.\n### Cách tạo một flashcard hiệu quả:\n- **Mặt trước:** Ghi từ mới.\n- **Mặt sau:**\n  - Định nghĩa (bằng tiếng Anh nếu có thể).\n  - **Câu ví dụ** (rất quan trọng, nên lấy từ bài đọc/nghe bạn đã học).\n  - Phiên âm (IPA).\n  - Word family (ví dụ: economy, economic, economical, economist).\n- **Công cụ:** Các ứng dụng như **Anki** (miễn phí, mạnh mẽ nhất), Quizlet, Memrise đều sử dụng SRS."
                },
                { 
                    "text": "Tập trung vào Collocations", 
                    "rank": 5, 
                    "connections": ["Đọc Chủ động", "Nghe & Xem Chủ động", "Luyện tập Sản sinh"],
                    "tooltip": "Collocation là những cụm từ thường đi với nhau một cách tự nhiên (ví dụ: 'make a decision', không phải 'do a decision'). PTE đánh giá rất cao việc sử dụng collocations chính xác, đặc biệt trong phần **Writing** và **Speaking**.\n### Tại sao Collocations lại quan trọng?\n- **Tăng điểm Fluency:** Giúp bạn nói và viết trôi chảy, tự nhiên hơn.\n- **Tăng điểm Vocabulary:** Thể hiện bạn có vốn từ sâu, không chỉ là từ đơn lẻ.\n- **Tránh lỗi sai:** Giúp bạn dùng từ đúng ngữ cảnh.\n### Cách học Collocations:\n- **Tạo một sổ tay Collocations:** Khi đọc hoặc nghe, nếu thấy một cụm từ hay (ví dụ: 'a compelling argument'), hãy ghi nó vào sổ.\n- **Sử dụng từ điển Collocations:** Các trang như Ozdic.com, freecollocation.com là công cụ tra cứu tuyệt vời."
                },
                { 
                    "text": "Luyện tập Sản sinh", 
                    "rank": 6, 
                    "connections": ["Đọc Chủ động", "Nghe & Xem Chủ động", "Tập trung vào Collocations", "Ôn tập & Tự kiểm tra"],
                    "tooltip": "'Use it or lose it' - Hãy sử dụng từ bạn đã học! Sản sinh (Production) là quá trình bạn chủ động tạo ra ngôn ngữ (viết và nói), đây là bước cuối cùng để biến từ vựng thụ động thành chủ động.\n### Cách luyện tập Writing:\n- **Viết tóm tắt:** Sau khi đọc một bài báo hoặc nghe một bài giảng, hãy viết một đoạn tóm tắt ngắn sử dụng các từ vựng và collocations mới học được.\n- **Viết essay:** Luyện viết các bài essay theo chủ đề của PTE. Cố gắng lồng ghép từ vựng học thuật một cách tự nhiên.\n### Cách luyện tập Speaking:\n- **Tự nói về một chủ đề:** Đặt một chủ đề bất kỳ (ví dụ: 'The impact of technology on society') và cố gắng nói về nó trong 1-2 phút, sử dụng các từ mới.\n- **Luyện các phần của PTE:** Áp dụng từ mới vào việc trả lời các câu hỏi **Describe Image**, **Re-tell Lecture**."
                },
                { 
                    "text": "Tận dụng Công cụ & Ứng dụng", 
                    "rank": 7, 
                    "connections": ["Flashcards & Lặp lại ngắt quãng"],
                    "tooltip": "Công nghệ là người bạn đồng hành đắc lực trong việc học từ vựng. Hãy biết cách chọn và sử dụng các công cụ một cách thông minh.\n### Các công cụ cần thiết:\n- **Từ điển Anh-Anh:** Oxford Learner's Dictionaries, Cambridge Dictionary. Chúng cung cấp định nghĩa, ví dụ, collocations và phát âm chuẩn.\n- **Ứng dụng Flashcard (SRS):** Anki (khuyến khích hàng đầu), Quizlet.\n- **Công cụ kiểm tra ngữ pháp & chính tả:** Grammarly. Giúp bạn nhận ra lỗi sai khi luyện viết.\n- **Trang web tra cứu Collocation:** Ozdic, FreeCollocation.\n- **YouTube & Podcast:** Nguồn tài liệu nghe vô tận."
                },
                { 
                    "text": "Ôn tập & Tự kiểm tra", 
                    "rank": 8, 
                    "connections": ["Flashcards & Lặp lại ngắt quãng", "Luyện tập Sản sinh"],
                    "tooltip": "Học từ mới chỉ là một nửa chặng đường. Việc ôn tập định kỳ và tự kiểm tra sẽ giúp bạn củng cố kiến thức và xác định những lỗ hổng cần cải thiện.\n### Xây dựng lịch ôn tập:\n- **Hàng ngày:** Dành 15-20 phút để ôn lại flashcards trên Anki/Quizlet.\n- **Hàng tuần:** Dành thời gian xem lại toàn bộ từ vựng đã học trong tuần. Thử đặt câu với những từ khó nhớ nhất.\n### Cách tự kiểm tra:\n- **Làm các bài tập Fill in the Blanks:** Đây là dạng bài kiểm tra từ vựng và collocations rất hiệu quả.\n- **Làm các bài thi thử (mock test):** Các bài thi thử sẽ cho bạn thấy bạn có thực sự áp dụng được từ vựng đã học vào môi trường áp lực thời gian hay không."
                }
            ];


            // Functions to create and render the diagram
            nodeData.forEach((node, index) => {
                node.isActive = true; 
                node.originalIndex = index;
                if (!node.rank) node.rank = index + 1;
            });
            
            const createControls = () => {
                controlsGrid.innerHTML = '';
                const sortedNodes = [...nodeData].sort((a, b) => a.rank - b.rank);

                sortedNodes.forEach(node => {
                    const controlItem = document.createElement('div');
                    controlItem.className = 'control-item';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `check-${node.originalIndex}`;
                    checkbox.checked = node.isActive;
                    checkbox.dataset.index = node.originalIndex;

                    const label = document.createElement('label');
                    label.htmlFor = `check-${node.originalIndex}`;
                    label.textContent = node.text;

                    controlItem.appendChild(checkbox);
                    controlItem.appendChild(label);
                    controlsGrid.appendChild(controlItem);

                    checkbox.addEventListener('change', (e) => {
                        const index = parseInt(e.target.dataset.index);
                        nodeData.find(n => n.originalIndex === index).isActive = e.target.checked;
                        renderDiagram();
                    });
                });
            };

            let renderedNodes = [];

            const renderDiagram = () => {
                const containerSize = Math.min(container.offsetWidth, container.offsetHeight);
                canvas.width = containerSize;
                canvas.height = containerSize;
                
                container.querySelectorAll('.circle-node').forEach(el => el.remove());
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const activeNodesData = nodeData.filter(node => node.isActive).sort((a,b) => a.rank - b.rank);

                if (activeNodesData.length > 0) {
                    createNodes(activeNodesData, containerSize);
                    drawNetworkLines();
                }
            };
            
            const createNodes = (activeNodes, containerSize) => {
                const numNodes = activeNodes.length;
                const nodeDiameterRatio = numNodes > 5 ? 0.20 : 0.24;
                const radius = containerSize / 2 * (numNodes > 1 ? 0.73 : 0);
                const centerX = containerSize / 2;
                const centerY = containerSize / 2;
                const nodeDiameter = containerSize * nodeDiameterRatio;
                const nodeRadius = nodeDiameter / 2;

                renderedNodes = [];

                activeNodes.forEach((data, i) => {
                    const angle = (i / numNodes) * Math.PI * 2 - Math.PI / 2;
                    const x = centerX + radius * Math.cos(angle) - nodeRadius;
                    const y = centerY + radius * Math.sin(angle) - nodeRadius;

                    const nodeElement = document.createElement('div');
                    nodeElement.classList.add('circle-node');
                    if (data.highlight) {
                        nodeElement.classList.add('highlight');
                    }
                    nodeElement.style.width = `${nodeDiameter}px`;
                    nodeElement.style.height = `${nodeDiameter}px`;
                    nodeElement.style.left = `${x}px`;
                    nodeElement.style.top = `${y}px`;
                    
                    const rankLabel = document.createElement('span');
                    rankLabel.classList.add('rank-label');
                    rankLabel.textContent = `Phương pháp ${data.rank}`; // Changed from "Luồng"
                    nodeElement.appendChild(rankLabel);

                    const textContent = document.createElement('span');
                    textContent.textContent = data.text;
                    nodeElement.appendChild(textContent);

                    nodeElement.dataset.originalIndex = data.originalIndex;
                    container.appendChild(nodeElement);

                    renderedNodes.push({
                        ...data,
                        x: x + nodeRadius,
                        y: y + nodeRadius,
                        radius: nodeRadius,
                        element: nodeElement
                    });

                    nodeElement.addEventListener('click', () => {
                        const clickedIndex = parseInt(nodeElement.dataset.originalIndex);
                        const originalNodeData = nodeData.find(n => n.originalIndex === clickedIndex);
                        modalTitle.textContent = originalNodeData.text;
                        modalBody.innerHTML = marked.parse(originalNodeData.tooltip); 
                        tooltipModal.classList.add('show');
                        tooltipModal.querySelector('.modal-content').scrollTop = 0;
                    });
                });
            };
            
            const drawNetworkLines = () => {
                ctx.strokeStyle = 'rgba(100, 116, 139, 0.7)';
                ctx.lineWidth = 2;
                ctx.setLineDash([]);

                const drawBidirectionalArrow = (context, fromX, fromY, toX, toY) => {
                    const headlen = 12;
                    const angle = Math.atan2(toY - fromY, toX - fromX);
                    const reverseAngle = angle + Math.PI;

                    context.beginPath();
                    context.moveTo(fromX, fromY);
                    context.lineTo(toX, toY);
                    
                    context.moveTo(toX, toY);
                    context.lineTo(toX - headlen * Math.cos(angle - Math.PI / 7), toY - headlen * Math.sin(angle - Math.PI / 7));
                    context.moveTo(toX, toY);
                    context.lineTo(toX - headlen * Math.cos(angle + Math.PI / 7), toY - headlen * Math.sin(angle + Math.PI / 7));

                    context.moveTo(fromX, fromY);
                    context.lineTo(fromX - headlen * Math.cos(reverseAngle - Math.PI / 7), fromY - headlen * Math.sin(reverseAngle - Math.PI / 7));
                    context.moveTo(fromX, fromY);
                    context.lineTo(fromX - headlen * Math.cos(reverseAngle + Math.PI / 7), fromY - headlen * Math.sin(reverseAngle + Math.PI / 7));

                    context.stroke();
                };
                
                const renderedNodeMap = new Map(renderedNodes.map(node => [node.text, node]));

                for (const node1 of renderedNodes) {
                    if (node1.connections) {
                        for (const connectionName of node1.connections) {
                             const node2 = renderedNodeMap.get(connectionName);
                             if (node2 && node1.rank < node2.rank) {
                                const angle = Math.atan2(node2.y - node1.y, node2.x - node1.x);
                                const startX = node1.x + node1.radius * Math.cos(angle);
                                const startY = node1.y + node1.radius * Math.sin(angle);
                                const endX = node2.x - node2.radius * Math.cos(angle);
                                const endY = node2.y - node2.radius * Math.sin(angle);

                                drawBidirectionalArrow(ctx, startX, startY, endX, endY);
                             }
                        }
                    }
                }
            };
            
            closeModalBtn.addEventListener('click', () => tooltipModal.classList.remove('show'));
            tooltipModal.addEventListener('click', (event) => {
                if (event.target === tooltipModal) {
                    tooltipModal.classList.remove('show');
                }
            });
            
            createControls();
            renderDiagram();
            window.addEventListener('resize', renderDiagram);
        });
    </script>
</body>
</html>